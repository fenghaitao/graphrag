# DMA Devices

This document describes DML 1.4 device models in the **DMA** category.

## Device List

- synopsys-ahb-dmac (DW Synopsys AHB DMA Controller)
- sample-dma-device (Educational Example)

## Key Features and DML Implementation

### synopsys-ahb-dmac

The Synopsys AHB DMAC is a production-quality DMA controller with comprehensive features.

#### Device Declaration

```dml
device synopsys_ahb_dmac;
param classname = "synopsys-ahb-dmac";
param desc = "DW Synopsys AHB DMAC";
```

#### Device Parameters

```dml
param documentation = "model of DW Synopsys AHB DMAC, REV 2.23a"
                    + "<br></br>"
                    + "Implements DW DMAC with these supported features:"
                    + "<ul>"
                    + "<li>All interrupts are simulated</li>"
                    + "<li>Hardware and software handshaking</li>"
                    + "<li>Linked lists on source and/or destination</li>"
                    + "<li>Auto reload of source and/or destination</li>"
                    + "<li>Scatter/Gather</li>"
                    + "<li>Flow controller can be source, DMAC or destination</li>"
                    + "<li>Increment/Fixed/Decrement source and/or destination address</li>"
                    + "<li>Prefetch/No-prefetch of source data</li>"
                    + "<li>Endian conversion</li>"
                    + "</ul>"
                    + "Limitations:"
                    + "<ul>"
                    + "<li>Bus locking unsupported</li>"
                    + "<li>DMA transfer suspend unsupported</li>"
                    + "<li>Write back status unsupported</li>"
                    + "</ul>";
```

### Physical Memory Interface Connection and Usage

DMA devices need to access system memory to transfer data. The physical memory interface provides this capability.

#### Memory Space Connection (sample-dma-device)

```dml
import "simics/devs/memory-space.dml";

connect target_mem_space {
    param documentation =
        "The memory space on which the DMA engine operates. Data will be "
        + "read from and copied to the memory associated with this memory "
        + "space.";
    param configuration = "required";
    interface memory_space;
}
```

**Description:**
- **Import**: Includes memory-space interface definitions
- **Connection**: Creates `target_mem_space` connection point
- **Configuration**: Marked as "required" - must be configured for device to work
- **Interface**: Uses `memory_space` interface for memory operations

#### Memory Read Method

```dml
method read_mem(void *dst,
                physical_address_t src,
                physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                src,
                                                dst,
                                                len,
                                                Sim_RW_Read,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when reading target memory";
        throw;
    }
}
```

**Description:**
- **Parameters**: Destination buffer, source address, length
- **access_simple()**: Simics API for memory access
  - `dev.obj`: Device object making the access
  - `src`: Physical address to read from
  - `dst`: Buffer to store read data
  - `len`: Number of bytes to read
  - `Sim_RW_Read`: Read operation flag
  - `Sim_Endian_Target`: Use target endianness
- **Error Handling**: Throws exception if memory access fails
- **Returns**: Data in dst buffer

#### Memory Write Method

```dml
method write_mem(physical_address_t dst,
                 const void *src,
                 physical_address_t len) throws {
    local exception_type_t exc;
    exc = target_mem_space.memory_space.access_simple(dev.obj,
                                                dst,
                                                cast(src, uint8*),
                                                len,
                                                Sim_RW_Write,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "an error occurred when writing to target memory";
        throw;
    }
}
```

**Description:**
- **Parameters**: Destination address, source buffer, length
- **access_simple()**: Same API for write operation
  - `dst`: Physical address to write to
  - `src`: Buffer containing data to write (cast to uint8*)
  - `Sim_RW_Write`: Write operation flag
- **Error Handling**: Throws exception on failure
- **Memory Safety**: Proper casting to uint8* pointer type

### Data Transferring Implementation

#### Contiguous Memory Transfer (sample-dma-device)

For simple linear memory transfers:

```dml
method copy_contiguous(physical_address_t dst,
                      physical_address_t src,
                      uint18 count) throws {
    local uint8 buf[count];
    read_mem(buf, src, count);
    write_mem(dst, buf, count);
}
```

**Description:**
- **Stack Buffer**: Creates temporary buffer on stack
- **Two-Step Process**: Read from source, then write to destination
- **Simple and Efficient**: For contiguous memory regions
- **Atomic**: All data read before any writes

#### FIFO Buffer Management (synopsys-ahb-dmac)

For pipelined transfers with buffering:

```dml
template fifo_buffer {
    saved uint32 read_pos;
    saved uint32 write_pos;
    session uint8* buf;
    param size : uint32;

    method bytes_filled() -> (uint32) {
        if (write_pos < read_pos)
            return size - (read_pos - write_pos);
        else
            return write_pos - read_pos;
    }

    method bytes_empty() -> (uint32) {
        return size - bytes_filled();
    }

    method copy_from_src(uint8* data, uint32 len) throws {
        assert(len > 0);
        assert(bytes_empty() >= len);

        if ((write_pos + len) <= size) {
            memcpy(&buf[write_pos], &data[0], len);
        } else {
            local uint32 len1 = size - write_pos;
            memcpy(&buf[write_pos], &data[0], len1);
            memcpy(&buf[0], &data[len1], len - len1);
        }
        write_pos = (write_pos + len) % size;
    }

    method copy_to_dst(uint8* data, uint32 len) throws {
        assert(len > 0);
        assert(bytes_filled() >= len);

        if ((read_pos + len) <= size) {
            memcpy(&data[0], &buf[read_pos], len);
        } else {
            local uint32 len1 = size - read_pos;
            memcpy(&data[0], &buf[read_pos], len1);
            memcpy(&data[len1], &buf[0], len - len1);
        }
        read_pos = (read_pos + len) % size;
    }

    method reset() {
        read_pos = 0;
        write_pos = 0;
    }
}
```

**Description:**
- **Circular Buffer**: Ring buffer with read and write pointers
- **Wraparound Handling**: Copies data across buffer boundary if needed
- **Space Management**: Tracks filled and empty space
- **Efficient**: Avoids unnecessary data copies by using pointers
- **Pipeline**: Allows overlapping read and write operations

#### Transaction Counter (synopsys-ahb-dmac)

Tracks transfer progress and handles stride operations:

```dml
template transaction_counter {
    saved uint32 single_bytes;
    saved uint32 burst_bytes;
    saved uint32 transferred_bytes;
    saved bool flow_done;
    saved bool striding;
    saved uint32 stride_bytes;
    saved int endian;

    method set_stride(uint32 stride_singles) {
        assert(stride_singles > 0);
        this.striding = true;
        this.stride_bytes = stride_singles * this.single_bytes;
    }

    method crossing_stride_boundary(uint32 bytes_to_add) -> (bool) {
        if (!this.striding)
            return false;

        local int index_now = this.transferred_bytes / this.stride_bytes;
        local uint32 bytes_after = this.transferred_bytes + bytes_to_add;
        local int index_after = (bytes_after - 1) / this.stride_bytes;
        return index_after > index_now;
    }

    method reached_stride_boundary() -> (bool) {
        if (!this.striding)
            return false;

        return (this.transferred_bytes % this.stride_bytes) == 0;
    }
}
```

**Description:**
- **Burst Tracking**: Tracks single and burst transfer sizes
- **Stride Support**: Handles strided access patterns
- **Boundary Detection**: Detects stride boundary crossings
- **Progress**: Tracks total transferred bytes

#### Endian-Aware Data Transfer (synopsys-ahb-dmac)

```dml
method read_from_src(uint32 len) throws {
    assert(!src_is_done());

    if (this.supports_unaligned())
        len -= (len + this.get_src_address()) % this.src.single_bytes;

    local uint8 buf[len];
    if (this.src.endian == ENDIAN.LITTLE) {
        address_space.read_bytes(this.get_src_address(), len, buf);
    } else if (this.src.endian == ENDIAN.BE_8) {
        address_space.read_bytes_swapped(this.get_src_address(),
                                         len, buf,
                                         this.src.single_bytes);
    } else {
        // BE32 endian conversion
        if (src_fixed_address()) {
            address_space.read_bytes(this.get_src_address(), len, buf);
        } else {
            address_space.read_bytes_be32(this.get_src_address(),
                                          len, buf, this.src.single_bytes);
        }
    }
    
    // Store in FIFO buffer
    this.fifo.copy_from_src(buf, len);
    
    // Update address and counters
    if (!src_fixed_address())
        this.update_src_address(len);
    this.src.transferred_bytes += len;
}
```

**Description:**
- **Unaligned Support**: Adjusts length for unaligned accesses
- **Endian Conversion**: Supports little-endian, BE8, and BE32
- **Fixed Address**: Handles fixed source addresses (for FIFOs)
- **FIFO Integration**: Stores data in circular buffer
- **Progress Tracking**: Updates counters and addresses

### Interrupt Triggering and Clearing

#### Interrupt Types (synopsys-ahb-dmac)

```dml
param TRANSFER_IRQ = 0;
param BLOCK_IRQ = 1;
param SRC_IRQ = 2;
param DST_IRQ = 3;
param ERR_IRQ = 4;
param NBR_IRQ_TYPES = 5;
```

**Description:**
- **TRANSFER_IRQ**: Complete DMA transfer done
- **BLOCK_IRQ**: Block transfer complete
- **SRC_IRQ**: Source transaction complete
- **DST_IRQ**: Destination transaction complete
- **ERR_IRQ**: Transfer error occurred

#### Interrupt Connection Template (synopsys-ahb-dmac)

```dml
template irq_type_connects {
    connect err "Error interrupt" {
        param type = ERR_IRQ;
    }
    connect dst "Destination transaction done interrupt" {
        param type = DST_IRQ;
    }
    connect src "Source transaction complete interrupt" {
        param type = SRC_IRQ;
    }
    connect block "Block transfer complete interrupt" {
        param type = BLOCK_IRQ;
    }
    connect transfer "DMA transfer complete interrupt" {
        param type = TRANSFER_IRQ;
    }
}
```

**Description:**
- **Template-Based**: Reusable interrupt connection pattern
- **Type Parameter**: Associates each connection with interrupt type
- **Documentation**: Clear description of each interrupt purpose

#### Combined and Per-Channel Interrupts (synopsys-ahb-dmac)

```dml
group irqs {
    group combined {
        connect global "Single combined interrupt for all types and channels" {
            is irq_connect;
        }
        is irq_type_connects;
    }
    group channel[i < DMAC_MAX_NUM_CHANNELS] {
        is irq_type_connects;
    }
}
```

**Description:**
- **Combined Mode**: Single interrupt line for all channels and types
- **Per-Channel**: Separate interrupt lines for each channel
- **Flexible**: Supports both wiring schemes

#### Interrupt Update Logic (synopsys-ahb-dmac)

```dml
template channel_irq is (irq_connect) {
    param type : int;
    param channel = i;
    param status_bit = channel;
}

group irqs {
    group channel[i < DMAC_MAX_NUM_CHANNELS] {
        connect transfer is (channel_irq) {
            param combined_irq = combined.transfer;
            param status_expr = regs.irq.transfer.status.get() != 0;
        }

        method update_all() {
            foreach irq in (each channel_irq in (this)) {
                irq.update();
            }
        }

        method update_type(int type) {
            foreach irq in (each channel_irq in (this)) {
                if (irq.type == type) {
                    irq.update();
                    return;
                }
            }
            assert(false);
        }
    }
}
```

**Description:**
- **Status Expression**: Evaluates register to determine interrupt state
- **Combined IRQ**: Can trigger combined interrupt line
- **Update Methods**: Update all interrupts or specific type
- **Automatic**: Interrupt lines update when status registers change

#### Interrupt Trigger (sample-dma-device)

```dml
import "simics/devs/signal.dml";

connect intr_target {
    param documentation = "Interrupt target port to signal on DMA interrupts.";
    param configuration = "required";
    interface signal;
}

method complete_dma() {
    log info, 2: "DMA transfer completed";

    // Clear SWT bit, update TS
    DMA_control.SWT.val = 0;
    DMA_control.TS.val = 0;
    DMA_control.TC.val = 1;

    // Raise interrupt towards CPU
    if(DMA_control.ECI.val == 0) {
        log info, 3: "ECI is zero, no interrupt raised";
        return;
    }

    log info, 3: "raising interrupt signal";
    intr_target.signal.signal_raise();

    // Remember that we raised it
    DMA_interrupt_posted = true;
}
```

**Description:**
- **Signal Interface**: Uses signal interface for interrupt generation
- **Conditional**: Only raises if interrupts enabled (ECI bit)
- **State Update**: Sets transfer complete (TC) bit
- **Tracking**: Remembers interrupt was posted for clearing logic
- **Logging**: Clear visibility into interrupt generation

#### Interrupt Clearing (sample-dma-device)

```dml
register DMA_control {
    field TC @ [28] "Transfer complete" {
        is write;
        method write(uint64 value) {
            if (value != 0) {
                log spec_viol: "write one to TC - ignored";
                return;
            }

            if (this.val == 0) // Already cleared
                return;

            log info, 3: "write zero to TC - clearing TC";
            this.val = 0;

            if (!DMA_interrupt_posted)
                return;

            log info, 3: "also clearing interrupt on CPU";
            DMA_interrupt_posted = false;
            intr_target.signal.signal_lower();
        }
    }
}
```

**Description:**
- **Write-to-Clear**: Writing 0 clears the interrupt
- **Write-1-Ignored**: Writing 1 is a spec violation (W1C pattern)
- **Conditional Clear**: Only lowers interrupt if it was posted
- **State Synchronization**: Clears both register bit and interrupt line
- **Logging**: Tracks clearing operations for debugging

### Scatter-Gather Implementation (sample-dma-device)

#### Data Structures

```dml
typedef layout "big-endian" {
    uint32 addr;
    uint16 len;
    uint16 reserved;
} sg_list_head_t;

typedef layout "big-endian" {
    uint32 addr;
    uint16 len;
    uint8 offset;
    bitfields 8 {
        uint1 ext @ [0:0];
    } flags;
} sg_list_block_row_t;
```

**Description:**
- **sg_list_head_t**: Header pointing to first block
- **sg_list_block_row_t**: Individual scatter-gather list entry
- **ext Flag**: Distinguishes data blocks (0) from extension blocks (1)
- **Offset**: Allows non-zero starting offset within block

#### Scatter-Gather Transfer Logic

```dml
method copy_scatter_gather(physical_address_t dst, physical_address_t src)
    -> (uint18) throws {
    local uint18 copied_bytes;
    
    // Get the header data
    local sg_list_head_t head;
    read_mem(&head, src, sizeof head);
    copied_bytes = 0;

    local physical_address_t addr = head.addr;
    local physical_address_t end_addr = head.addr + head.len;
    local physical_address_t hare_addr = addr;
    local physical_address_t hare_end_addr = end_addr;

    // Continue running through the lists until the end is reached
    local sg_list_block_row_t row;
    local bool finished = false;
    local bool hare_finished = false;
    
    while (!finished && DMA_control.ERR.val == 0) {
        read_mem(&row, addr, sizeof row);

        if (!row.flags.ext) { // Data block
            log info, 4: "Data block of length %d at 0x%x with offset %d",
                row.len, row.addr, row.offset;
            // Copy a block of data
            copy_contiguous(dst, row.addr + row.offset, row.len);
            dst += row.len;
            copied_bytes += row.len;
        } else {
            log info, 4: "Extension block of length %d at 0x%x with offset %d",
                row.len, row.addr, row.offset;
        }

        (addr, end_addr, finished) = next_row(addr, end_addr);

        // Loop detection using tortoise and hare algorithm
        if (!hare_finished) {
            local int8 i;
            for (i = 0; i < 2; i++) {
                (hare_addr, hare_end_addr, hare_finished) = 
                    next_row(hare_addr, hare_end_addr);
                if (hare_finished) {
                    log info, 4: "Loop checker finished, no loops";
                    break;
                }
            }
            if (hare_addr == addr) {
                log spec_viol: "Stuck in a loop.";
                DMA_control.ERR.val = 1;
            }
        }
    }
    return copied_bytes;
}
```

**Description:**
- **Header Read**: Reads scatter-gather list header
- **List Traversal**: Iterates through linked list entries
- **Data vs Extension**: Handles both data and extension blocks
- **Loop Detection**: Uses tortoise and hare algorithm to detect circular lists
- **Error Handling**: Stops on error or loop detection
- **Progress Tracking**: Returns total bytes copied

#### Next Row Navigation

```dml
method next_row(physical_address_t addr, physical_address_t end_addr)
    -> (physical_address_t, physical_address_t, bool) 
    throws /* next_addr, next_end_addr, finished */ {
    local physical_address_t next_addr;
    local physical_address_t next_end_addr;
    local bool finished;
    local sg_list_block_row_t block_row;
    
    read_mem(&block_row, addr, sizeof block_row);
    
    if (block_row.flags.ext) {
        // Extension block - jump to new location
        next_addr = block_row.addr + block_row.offset;
        next_end_addr = next_addr + block_row.len;
    } else {
        // Data block - continue sequentially
        next_addr = addr + sizeof block_row;
        next_end_addr = end_addr;
    }
    
    finished = next_addr == end_addr;
    return (next_addr, next_end_addr, finished);
}
```

**Description:**
- **Extension Blocks**: Jump to new memory location
- **Data Blocks**: Continue sequentially in current block
- **End Detection**: Checks if reached end of list
- **Triple Return**: Returns next address, end address, and finished flag

#### DMA Transfer Initiation

```dml
method do_dma_transfer() {
    if (DMA_control.SWT.val == 0)
        return; // No need to do anything if we are not asked by software

    // Software asked us to initiate a DMA transfer
    if(DMA_control.EN.val == 0) {
        // enable bit not set, so we cannot transfer
        log info, 2: "EN bit not set, SWT = 1 has no effect";
        return;
    }

    log info, 3: "EN bit set, SWT written, initiating DMA";
    log info, 3: "Transferring %d 32-bit words from 0x%x to 0x%x",
        DMA_control.TS.val, DMA_source.val, DMA_dest.val;

    local uint18 count = DMA_control.TS.val * 4;
    try {
        if (DMA_control.SG.val != 0) {
            log info, 4: "Scatter Gather Transfer";
            count = copy_scatter_gather(DMA_dest.val, DMA_source.val);
        } else {
            log info, 4: "Contiguous Transfer";
            copy_contiguous(DMA_dest.val, DMA_source.val, count);
        }
    } catch {
        log error: "DMA memory access failed";
        return;
    }

    // Schedule completion based on throttle
    after throttle.val * count / 4.0 s: complete_dma();
}
```

**Description:**
- **Enable Check**: Verifies DMA is enabled (EN bit)
- **Trigger Check**: Activated by software trigger (SWT bit)
- **Mode Selection**: Chooses contiguous or scatter-gather based on SG bit
- **Error Handling**: Catches and logs memory access failures
- **Timing**: Schedules completion event based on throughput throttle

## Summary

DMA devices in DML 1.4 implement several key patterns:

1. **Physical Memory Interface**: Uses `memory_space` interface for system memory access
2. **Memory Access Methods**: `access_simple()` for reads and writes with error handling
3. **Contiguous Transfer**: Simple buffer-based memory-to-memory copy
4. **FIFO Buffering**: Circular buffer for pipelined transfers
5. **Endian Conversion**: Support for little-endian, BE8, and BE32
6. **Interrupt Management**: Multiple interrupt types with combined/per-channel modes
7. **Interrupt Generation**: `signal_raise()` with conditional logic
8. **Interrupt Clearing**: Write-to-clear pattern with state synchronization
9. **Scatter-Gather**: Linked list traversal with loop detection
10. **Transfer Modes**: Support for contiguous and scatter-gather operations

The implementation demonstrates:
- Efficient DMA modeling with event-based completion
- Proper memory interface usage with error handling
- Flexible interrupt architecture supporting multiple configurations
- Robust scatter-gather with loop detection
- Professional-grade feature set matching hardware capabilities
