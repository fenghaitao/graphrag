# I2C Devices

This document describes DML 1.4 device models in the **I2C** category.

## Device List

- synopsys-apb-i2c (DW Synopsys APB I2C Controller/Target)
- sample-i2c-device (Educational Example)
- i2c-link-v2 (I2C Bus Link)

## Key Features and DML Implementation

### synopsys-apb-i2c

The Synopsys APB I2C is a production-quality I2C controller and target with comprehensive features.

#### Device Declaration

```dml
device synopsys_apb_i2c;
param classname = "synopsys-apb-i2c";
param desc = "DW Synopsys APB I2C";
```

#### Device Parameters

```dml
param documentation = "model of DW Synopsys APB I2C REV 2.04a"
                    + "<br></br>"
                    + "Supported features:"
                    + "<ul>"
                    + "<li>7-bit addressing</li>"
                    + "<li>Controller and target mode supported</li>"
                    + "<li>Bulk transfer supported</li>"
                    + "<li>High speed mode</li>"
                    + "<li>All interrupts are modeled</li>"
                    + "<li>SMBus Quick protocol for controller and target</li>"
                    + "<li>SMBus Host notify protocol for controller and target</li>"
                    + "<li>SMBus Alert for controller and target</li>"
                    + "</ul>"
                    + "Limitations:"
                    + "<ul>"
                    + "<li>10-bit addressing is not supported</li>"
                    + "<li>SMBUS ARP Protocol is not supported</li>"
                    + "<li>General Call in target mode is not supported</li>"
                    + "<li>DMA handshaking interface is not supported</li>"
                    + "</ul>";
```

### I2C Protocol Implementation

#### State Machine

The I2C controller uses a state machine to manage transactions:

```dml
/* Controller Mode States */
param ST_IDLE     = 0;
param ST_WRITE    = 1;
param ST_READ     = 2;
param ST_GEN_CALL = 3;
param ST_STUCK    = 4;
param ST_STUCK_RECOVERY = 5;

/* Target Mode States */
param TGT = 31;  /* bit to indicate target state */
param ST_TGT_WRITE = (1 << TGT) | ST_WRITE;
param ST_TGT_READ  = (1 << TGT) | ST_READ;
param ST_TGT_GC    = (1 << TGT) | ST_GEN_CALL;
param ST_TGT_QCMD  = (1 << TGT) | 5;
param ST_TGT_HOST_NOTIFY  = (1 << TGT) | 6;
param ST_TGT_SMBUS_ALERT_ADDR  = (1 << TGT) | 7;
param ST_TGT_SMBUS_ALERT_PEC  = (1 << TGT) | 8;

saved uint64 i2c_state;

method hard_reset() {
    default();
    i2c_state = ST_IDLE;
    update_interrupts();
}
```

#### Command Pipeline

Commands are queued and processed sequentially:

```dml
/* Command pipe constants */
param CMD_INVALID = 0;
param CMD_START   = 1;
param CMD_WRITE   = 2;
param CMD_READ    = 3;
param CMD_STOP    = 4;
param CMD_RESTART = 5;
```

#### Address Handling

```dml
/* START byte definitions */
param GENERAL_CALL = 0b00000000;
param HS_MODE      = 0b00001;
param TENBIT_ADDR  = 0b11110;
param SMBUS_HOST   = 0b0001000;
param SMBUS_ALERT  = 0b0001100;
param SMBUS_DDA    = 0b1100001;

param RnW = 0x1;  /* Read/Write bit */
```

### Interrupt Generation

The I2C controller supports 20 interrupt sources:

```dml
/* Interrupt bit definitions */
param RX_UNDER    = 0;
param RX_OVER     = 1;
param RX_FULL     = 2;
param TX_OVER     = 3;
param TX_EMPTY    = 4;
param RD_REQ      = 5;
param TX_ABORT    = 6;
param RX_DONE     = 7;
param ACTIVITY    = 8;
param STOP_DET    = 9;
param START_DET   = 10;
param GEN_CALL    = 11;
param RESTART_DET = 12;
param CONTROLLER_HOLD = 13;
param SCL_STUCK   = 14;
param WR_REQ = 15;
param TGT_ADDR1_TAG = 16;
param TGT_ADDR2_TAG = 17;
param TGT_ADDR3_TAG = 18;
param TGT_ADDR4_TAG = 19;
param NBR_INTERRUPTS = 20;
```

**Interrupt Register Template:**

```dml
template intr_reg is (register) {
    field TGT_ADDR4_TAG @ [19];
    field TGT_ADDR3_TAG @ [18];
    field TGT_ADDR2_TAG @ [17];
    field TGT_ADDR1_TAG @ [16];
    field WR_REQ @ [15];
    field SCL_STUCK_AT_LOW @ [14];
    field CONTROLLER_ON_HOLD @ [13];
    field RESTART_DET @ [12];
    field GEN_CALL @ [11];
    field START_DET @ [10];
    field STOP_DET @ [9];
    field ACTIVITY @ [8];
    field RX_DONE @ [7];
    field TX_ABRT @ [6];
    field RD_REQ @ [5];
    field TX_EMPTY @ [4];
    field TX_OVER @ [3];
    field RX_FULL @ [2];
    field RX_OVER @ [1];
    field RX_UNDER @ [0];
}
```

### SMBus Support

SMBus-specific interrupts and features:

```dml
param NBR_SMBUS_INTERRUPTS = 11;

template smbus_intr_reg is (register) {
    field SMBUS_ALERT_DET         @ [10];
    field SMBUS_SUSPEND_DET       @ [9];
    field TGT_RX_PEC_NACK         @ [8];
    field ARP_ASSGN_ADDR_CMD_DET  @ [7];
    field ARP_GET_UDID_CMD_DET    @ [6];
    field ARP_RST_CMD_DET         @ [5];
    field ARP_PREPARE_CMD_DET     @ [4];
    field HOST_NTFY_MST_DET       @ [3];
    field QUICK_CMD_DET           @ [2];
    field MST_CLOCK_EXTND_TIMEOUT @ [1];
    field TGT_CLOCK_EXTND_TIMEOUT @ [0];
}
```

### I2C Interface Implementation

```dml
import "simics/devs/i2c.dml";

connect i2c_bus {
    interface i2c_master_v2;
    interface i2c_slave_v2;
    param documentation = "I2C bus connection";
}
```

## Summary

I2C devices in DML 1.4 implement:

1. **Dual-Mode Operation**: Controller and target mode support
2. **State Machine**: Manages transaction states and transitions
3. **Command Pipeline**: Queues and processes I2C commands
4. **Address Management**: Handles 7-bit addressing and special addresses
5. **Interrupt System**: 20 interrupt sources with priority handling
6. **SMBus Extensions**: Additional SMBus protocol features
7. **FIFO Buffering**: TX and RX FIFOs for efficient data transfer
8. **Speed Control**: Support for standard, fast, and high-speed modes

The implementation demonstrates efficient I2C modeling with event-based transaction processing and proper protocol state management.
