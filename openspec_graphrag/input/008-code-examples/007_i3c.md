# I3C Devices

This document describes DML 1.4 device models in the **I3C** category.

## Device List

- synopsys-mipi-i3c (DW Synopsys MIPI I3C Controller)
- sample-i3c-devices (Educational Example)
- i3c-link (I3C Bus Link)

## Key Features and DML Implementation

### synopsys-mipi-i3c

The Synopsys MIPI I3C is a production-quality I3C controller implementing the MIPI I3C specification.

#### Device Declaration

```dml
device synopsys_mipi_i3c;
param classname = "synopsys-mipi-i3c";
param desc = "DW Synopsys MIPI I3C Host Controller";
```

#### Device Parameters

```dml
param documentation = "model of DW Synopsys MIPI I3C Host Controller"
                    + "<br></br>"
                    + "Supported features:"
                    + "<ul>"
                    + "<li>I3C private read/write transfers</li>"
                    + "<li>I3C broadcast and direct CCC (Common Command Codes)</li>"
                    + "<li>I2C legacy transfers</li>"
                    + "<li>Dynamic address assignment (DAA)</li>"
                    + "<li>In-Band Interrupt (IBI) support</li>"
                    + "<li>Hot-Join capability</li>"
                    + "<li>Command queue and response queue</li>"
                    + "<li>TX and RX data buffers</li>"
                    + "</ul>";
```

### I3C Protocol Implementation

#### Error Status Codes

```dml
group ERR_STS {
    param NO_ERR = 0;
    param CRC_ERR = 1;
    param PARITY_ERR = 2;
    param FRAME_ERR = 3;
    param BR_NACK_ERR = 4;
    param ADDR_NACK_ERR = 5;
    param UNDER_OVER_FLOW = 6;
    param TRANSFER_ABORT = 8;
    param I2C_WR_NACK_ERR = 9;
    param PEC_ERR = 12;
}
```

#### Response Handling

```dml
method post_response(uint5 err, uint4 tid, uint16 len) {
    local response_t response = {
        .ERR_STS = err,
        .TID = tid,
        .CCCT = 0,
        .DL = len,
    };
    log info, 3: "Response len=%d tid=%d err=%d", len, tid, err;
    regs.RESPONSE_QUEUE_PORT.fifo.push(response);
    if (err != ERR_STS.NO_ERR)
        regs.INTR_STATUS.TRANSFER_ERR.source_raised();
}
```

### Transfer State Machine

The I3C controller uses a sophisticated transfer machine:

```dml
template ctrl_transfer_machine is (hard_reset) {
    param top_machine = cast(this.parent, ctrl_top_machine);
    saved bool active;
    saved ctrl_cmd_impl impl;

    shared method reset();
    shared method user_abort();
    shared method done();
    shared method peer_abort();

    method hard_reset() {
        this.reset();
        default();
    }
    
    method reset() {
        active = false;
        impl.cancel_after();
        impl = _invalid_cmd;
    }
    
    method user_abort() {
        log info, 3: "%s user aborting %s", qname, impl.to_str;
        impl.user_abort();
        reset();
    }
    
    method done() {
        log info, 4: "%s completed %s", qname, impl.to_str;
        reset();
        top_machine.transfer_done();
    }
    
    method peer_abort() {
        log info, 2: "%s aborting %s", qname, impl.to_str;
        reset();
        top_machine.transfer_peer_abort();
    }
    
    method carry_on() {
        if (active)
            impl.carry_on();
    }
}
```

### Transfer Types

The controller supports multiple transfer types:

```dml
method enter_br_ccc_write(cmd_trf_cmd_t cmd, cmd_trf_arg_t arg) {
    enter_transfer(cast(i3c_br_ccc_write, ctrl_transfer_impl), cmd, arg);
}

method enter_dir_ccc_write(cmd_trf_cmd_t cmd, cmd_trf_arg_t arg) {
    enter_transfer(cast(i3c_dir_ccc_write, ctrl_transfer_impl), cmd, arg);
}

method enter_dir_ccc_read(cmd_trf_cmd_t cmd, cmd_trf_arg_t arg) {
    enter_transfer(cast(i3c_dir_ccc_read, ctrl_transfer_impl), cmd, arg);
}

method enter_priv_write(cmd_trf_cmd_t cmd, cmd_trf_arg_t arg) {
    enter_transfer(cast(i3c_priv_write, ctrl_transfer_impl), cmd, arg);
}

method enter_priv_read(cmd_trf_cmd_t cmd, cmd_trf_arg_t arg) {
    enter_transfer(cast(i3c_priv_read, ctrl_transfer_impl), cmd, arg);
}

method enter_i2c_write(cmd_trf_cmd_t cmd, cmd_trf_arg_t arg) {
    enter_transfer(cast(i2c_priv_write, ctrl_transfer_impl), cmd, arg);
}

method enter_i2c_read(cmd_trf_cmd_t cmd, cmd_trf_arg_t arg) {
    enter_transfer(cast(i2c_priv_read, ctrl_transfer_impl), cmd, arg);
}
```

### Dynamic Address Assignment

I3C supports dynamic address assignment for devices:

```dml
method enter_setdasa(cmd_addr_assign_t cmd) {
    assert(!active);
    this.impl = cast(da_setdasa_cmd, ctrl_cmd_impl);
    active = true;
    log info, 3: "%s Starting %s", qname, impl.to_str;
    da_setdasa_cmd.enter(cmd);
}

method enter_entdaa(cmd_addr_assign_t cmd) {
    assert(!active);
    this.impl = cast(da_entdaa_cmd, ctrl_cmd_impl);
    active = true;
    log info, 3: "%s Starting %s", qname, impl.to_str;
    da_entdaa_cmd.enter(cmd);
}
```

### In-Band Interrupt (IBI)

I3C devices can send interrupts over the I3C bus:

```dml
method enter_ibi() {
    assert(!active);
    this.impl = cast(ibi_transfer, ctrl_cmd_impl);
    active = true;
    log info, 3: "%s Starting %s", qname, impl.to_str;
    ibi_transfer.enter();
}
```

### PEC (Packet Error Checking)

I3C supports optional PEC for error detection:

```dml
method trf_post_success_response(cmd_trf_cmd_t cmd, uint16 len) {
    if (TEST_TRIGGER_TRANSFER_PEC_ERROR.val && cmd.PEC == 1) {
        log info, 2: "attribute %s is set generating PEC error for transfer #%d",
            TEST_TRIGGER_TRANSFER_PEC_ERROR.qname, cmd.TID;
        
        TEST_TRIGGER_TRANSFER_PEC_ERROR.val = false;
        post_response(ERR_STS.PEC_ERR, cmd.TID, len);
    } else if (cmd.ROC == 1) {
        post_response(ERR_STS.NO_ERR, cmd.TID, len);
    }
}
```

### I3C Interface Implementation

```dml
import "simics/devs/i3c.dml";

connect i3c_bus {
    interface i3c_master;
    interface i3c_slave;
    param documentation = "I3C bus connection";
}
```

### Command and Response Queues

I3C uses command and response queues for efficient operation:

```dml
// Command queue for outgoing transactions
register COMMAND_QUEUE_PORT {
    param configuration = "pseudo";
    method write(uint64 value) {
        // Push command to queue
        command_queue.push(value);
        process_commands();
    }
}

// Response queue for completed transactions
register RESPONSE_QUEUE_PORT {
    param configuration = "pseudo";
    method read() -> (uint64) {
        if (!response_queue.is_empty()) {
            return response_queue.pop();
        }
        return 0;
    }
}
```

## Summary

I3C devices in DML 1.4 implement:

1. **Advanced Protocol**: Full MIPI I3C specification support
2. **Backward Compatibility**: Legacy I2C transaction support
3. **Dynamic Addressing**: SETDASA and ENTDAA for address assignment
4. **CCC Support**: Broadcast and direct Common Command Codes
5. **In-Band Interrupts**: IBI for device-initiated communication
6. **Hot-Join**: Dynamic device addition to the bus
7. **Error Handling**: Comprehensive error status codes (CRC, parity, etc.)
8. **PEC Support**: Optional packet error checking
9. **Queue-Based Operation**: Command and response queues for efficiency
10. **Transfer State Machine**: Complex state management for various transfer types

The implementation demonstrates sophisticated I3C modeling with:
- Multiple transfer types (private read/write, CCC, address assignment)
- State machine-based transaction management
- Error detection and recovery mechanisms
- Queue-based command processing
- Backward compatibility with I2C devices
