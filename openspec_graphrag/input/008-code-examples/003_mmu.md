# MMU Devices

This document describes DML 1.4 device models in the **MMU (Memory Management Unit)** category.

## Device List

- arm-mmu-600 (ARM CoreLink MMU-600 SMMU v3)
- arm-mmu-500 (ARM CoreLink MMU-500 SMMU v2)

## Key Features and DML Implementation

### arm-mmu-600

The ARM CoreLink MMU-600 is a System Memory Management Unit (SMMU) compliant with ARM SMMUv3 architecture, providing address translation and memory protection for system devices.

## 1. Device Declaration and Basic Setup

#### Device Declaration

```dml
dml 1.4;

device arm_mmu600;

param desc = "model of MMU-600";
param documentation = "ARM CoreLink MMU-600";
```

**Description:**
- **DML Version**: Uses DML 1.4 syntax and features
- **Device Name**: Declares the device class as arm_mmu600
- **Parameters**: Provides short description and documentation strings
- **Purpose**: Creates SMMU v3 compliant memory management unit

#### Connect Interfaces for Memory Spaces

```dml
connect target_mem_space is (map_target) {
    param documentation = "TCU memory space";
    param configuration = "required";
}

connect tbu_mem_space is (map_target) {
    param documentation = "TBU memory space";
}
```

**Description:**
- **target_mem_space**: Primary connection to system memory for TCU (Translation Control Unit) operations
- **Configuration**: Marked as "required" - must be configured for device to function
- **tbu_mem_space**: Secondary memory space for TBU (Translation Buffer Unit) operations
- **map_target**: Uses map_target interface for memory space connections
- **Purpose**: Enables MMU to access physical memory for translation table walks and data access

#### Attributes for Configuration

```dml
attribute NS_SPACE         is (uint64_attr) "Non-secure address space offset";
attribute tlb_cache_enable is (bool_attr)   "Enable a translation cache";
attribute tlb_cache_depth  is (uint64_attr, init) {
    param documentation = "The maximum number of cache entries per TBU";
    method init() {
        this.val = 65536;
    }
}

attribute tcu_sid {
    param documentation = "The DeviceID for TCU-generated MSIs";
    param type = "n|i";
    session int val = SID_NOT_SET;
    method get() -> (attr_value_t) {
        return val == SID_NOT_SET ? SIM_make_attr_nil()
                                  : SIM_make_attr_int64(val);
    }
    method set(attr_value_t value) throws {
        val = SIM_attr_is_nil(value) ? SID_NOT_SET
                                     : SIM_attr_integer(value);
    }
}
```

**Description:**
- **NS_SPACE**: Defines offset for non-secure address space mapping (security feature)
- **tlb_cache_enable**: Boolean flag to enable/disable TLB caching for performance
- **tlb_cache_depth**: Configures TLB cache size (default 65536 entries per TBU)
- **tcu_sid**: Stream ID for Message Signaled Interrupts from TCU
- **Type "n|i"**: Accepts either nil or integer value
- **Custom get/set**: Implements special handling for nil values
- **Purpose**: Provides runtime configuration for MMU behavior and performance tuning

## 2. Translator Interface Implementation

The MMU-600 implements both legacy and modern translator interfaces to support different Simics versions and use cases.

#### Legacy Translator Interface (mmu600-translator.dml)

```dml
import "simics/devs/translator.dml";
import "arm-smmu-translate-interface.dml";

implement arm_smmu_translator {
    method translate(conf_object_t *caller, physical_address_t addr,
                     access_t access, const map_target_t *default_target,
                     arm_smmu_info_t *info) -> (translation_t) {
        local transaction_context_t ctx;
        local translation_t txl;

        // Validate access type (single-bit mask only)
        if (!(access == Sim_Access_Read || access == Sim_Access_Write || 
              access == Sim_Access_Execute))
            return txl;

        // Initialize context with stream attributes
        apply_default_attr(&ctx);
        ctx.input_addr = addr;
        ctx.access = access;
        ctx.sid = info->sid;          // Stream ID
        ctx.ssid = info->ssid;        // SubStream ID
        ctx.attr_ns = ~info->secsid | info->ns;  // Non-secure attribute
        // ... (other context fields)

        // Perform cached translation
        address_translate_cached(&ctx);
        
        if (ctx.fault == 0) {
            // Success: return page-aligned translation
            if (ctx.attr_ns)
                ctx.output_addr |= NS_SPACE.val;
            txl.target = default_target;
            txl.base = addr & ~(ctx.page_size - 1);
            txl.start = ctx.output_addr & ~(ctx.page_size - 1);
            txl.size = ctx.page_size;
        } else {
            // Fault: report error and return NULL target
            if (ctx.fault != ABORT_NO_EVENT)
                send_eventq_record(&ctx);
            txl.target = NULL;
        }

        return txl;
    }
}
```

**Description:**
- **Interface Import**: Uses Simics translator interface and ARM SMMU-specific extensions
- **Access Validation**: Only accepts single-bit access masks (Read, Write, or Execute)
- **Context Setup**: Initializes translation context with stream attributes
  - `sid`: Stream ID identifying the device
  - `ssid`: SubStream ID for finer-grained identification
  - `secsid`: Security state identifier
  - `attr_rnw`: Read (1) or Write (0) indicator
  - `attr_ind`: Instruction (1) or Data (0) access
  - `attr_pnu`: Privileged (1) or Unprivileged (0) access
- **Translation**: Calls cached translation function for performance
- **Error Handling**: Returns NULL target on translation faults and logs events
- **Page-Aligned**: Returns translation with base and start addresses page-aligned
- **Security**: Applies non-secure offset if non-secure transaction

#### Transaction Translator Interface (mmu600-transaction.dml)

Modern transaction-based interface supporting ARM atoms and extended attributes:

```dml
import "simics/base/transaction.dml";
import "simics/arch/arm.dml";

constant NUM_TBU = 62;

port tbu[i < NUM_TBU] "TBU Interface (where masters connect)" {
    connect physical_memory is (map_target);
    
    implement transaction_translator {
        method translate(uint64 addr, access_t access, transaction_t *prev,
                         exception_type_t (*callback)(...), cbdata_register_t cbdata) 
                         -> (exception_type_t) {
            local transaction_context_t ctx;
            local translation_t txl;

            // Validate access type
            if (!(access == Sim_Access_Read || access == Sim_Access_Write || 
                  access == Sim_Access_Execute))
                return callback(txl, prev, cbdata);

            // Extract ARM transaction atoms
            ctx.input_addr = addr;
            ctx.access = access;
            ctx.initiator = SIM_transaction_initiator(prev);
            ctx.atoms.input.privileged = ATOM_get_transaction_arm_privileged(prev);
            ctx.atoms.input.nonsecure = ATOM_get_transaction_arm_nonsecure(prev);
            ctx.atoms.input.mem.u64 = ATOM_get_transaction_arm_memory_attributes(prev);
            ctx.atoms.input.mmu.u64 = ATOM_get_transaction_arm_smmu_attributes(prev);

            // Check TLB cache, translate on miss
            if (!tlb_cache_lookup(&ctx)) {
                apply_default_attr(&ctx);
                ctx_transaction_to_attr(&ctx);
                address_translate(&ctx);
                if (ctx.fault != 0) {
                    send_eventq_record(&ctx);
                    txl.target = NULL;
                    return callback(txl, prev, cbdata);
                }
                ctx_attr_to_transaction(&ctx);
                tlb_cache_update(&ctx);
            }

            // Build translation result with page-aligned addresses
            if (ctx.atoms.output.nonsecure)
                ctx.output_addr |= NS_SPACE.val;
            txl.base = addr & ~(ctx.page_size - 1);
            txl.start = ctx.output_addr & ~(ctx.page_size - 1);
            txl.size = ctx.page_size;
            txl.target = physical_memory.map_target ?: tbu_mem_space.map_target;

            // Propagate ARM atoms to downstream transaction
            local transaction_t t;
            local atom_t atoms[4] = {
                ATOM_arm_privileged(ctx.atoms.output.privileged),
                ATOM_arm_nonsecure(ctx.atoms.output.nonsecure),
                ATOM_arm_memory_attributes(ctx.atoms.output.mem.u64),
                ATOM_list_end(0)
            };
            t.prev = prev;
            t.atoms = atoms;
            return callback(txl, &t, cbdata);
        }
    }
}
```

**Description:**
- **Multiple TBUs**: Supports 62 Translation Buffer Units (ports) for parallel translations
- **Transaction Atoms**: Extracts ARM-specific attributes from transaction atoms
  - `privileged`: Privilege level of access
  - `nonsecure`: Security state
  - `mem.u64`: Memory attributes (cacheability, shareability)
  - `mmu.u64`: SMMU-specific attributes (SID, SSID)
- **TLB Cache**: Checks TLB cache first for performance optimization
- **Translation Path**: Falls through to full translation if cache miss
- **Callback Pattern**: Uses callback mechanism for asynchronous translation
- **Atom Propagation**: Forwards translated attributes to downstream transaction
- **Flexible Routing**: Selects appropriate memory space target
- **Performance**: Caches successful translations for repeated access patterns

## 3. Address Translation Implementation

The core translation engine implementing ARM SMMUv3 two-stage address translation.

#### Main Address Translation Function

```dml
method address_translate(transaction_context_t *ctx) {
    // Check bypass conditions
    smmu_bypass(ctx);
    if (ctx->bypass || ctx->fault != 0)
        return;

    // Fetch and validate Stream Table Entry
    fetch_ste(ctx);
    check_ste(ctx);
    if (ctx->fault != 0 || ctx->bypass)
        return;

    // Stage 1: VA → IPA
    if (ctx->has_s1) {
        check_ssid(ctx);
        fetch_cd(ctx);
        ctx->ipa = walk_stage1(ctx);
    } else {
        ctx->ipa = ctx->input_addr;  // Bypass S1
    }

    // Stage 2: IPA → PA
    if (ctx->has_s2) {
        ctx->output_addr = walk_stage2(ctx);
    } else {
        ctx->output_addr = ctx->ipa;  // Bypass S2
    }
}
```

**Description:**
- **Bypass Check**: First checks if translation can be bypassed entirely
- **STE Fetch**: Retrieves Stream Table Entry based on Stream ID
- **Two-Stage Translation**: Implements ARM's two-stage translation model
  - **Stage 1**: Virtual Address (VA) → Intermediate Physical Address (IPA)
  - **Stage 2**: IPA → Physical Address (PA)
- **Context Descriptor**: Fetches CD for Stage 1 if enabled
- **Flexible Pipeline**: Supports bypass at multiple stages
  - SMMU-level bypass
  - Stream-level bypass
  - Translation Regime bypass
- **Error Propagation**: Returns early on any fault condition
- **IPA Handling**: Can return IPA for ATS (Address Translation Service) requests
- **Logging**: Comprehensive logging at each stage for debugging

#### Translation Table Walk Implementation

```dml
method translation_table_walk(transaction_context_t *ctx, int current_stage,
    uint64 va) -> (uint64) {
    local uint64 ttbr, desc, pa;
    local uint8 page_level, trans_scheme;

    // Determine translation scheme (AArch64 or AArch32)
    trans_scheme = (current_stage == 1) ? get_s1_scheme(ctx) : get_s2_scheme(ctx);

    // Select TTBR and calculate starting level
    ttbr = select_ttbr(ctx, current_stage, va);
    page_level = calculate_start_level(ctx);

    // Walk page table levels
    for (level from page_level to 3) {
        desc = read_descriptor(ttbr, va, level);
        
        if (is_invalid(desc)) {
            ctx->fault = TRANSLATION_FAULT;
            return 0;
        }
        
        if (is_block_entry(desc, level)) {
            pa = extract_output_address(desc, va);
            return pa;
        }
        
        // Table entry - continue to next level
        ttbr = get_next_table_base(desc);
    }
    
    return pa;
}
```

**Description:**
- **Multi-Stage**: Handles both Stage 1 and Stage 2 translation walks
- **Translation Schemes**: AArch64 and AArch32 long-descriptor formats
- **TTBR Selection**: Selects Translation Table Base Register based on stage and address
- **Walk Algorithm**: Iterate page table levels → read descriptor → check type (Invalid/Block/Table) → extract PA or continue
- **Key Operations**:
  - `get_s1_scheme/get_s2_scheme`: Determine translation format
  - `select_ttbr`: Choose appropriate base register
  - `calculate_start_level`: Determine starting level from page granule size
  - `read_descriptor`: Fetch table entry from memory
  - `is_invalid/is_block_entry`: Check descriptor type
  - `extract_output_address`: Get physical address from block entry
  - `get_next_table_base`: Get next level table address


#### TLB Cache Implementation

High-performance translation caching using interval trees:

```dml
method tlb_cache_lookup(transaction_context_t *ctx) -> (bool) {
    if (!tlb_cache_enable.val)
        return false;
    
    // Query interval tree for matching address range
    local int n = get_interval_vector(&tlb_cache, ctx->input_addr, &match_list);
    for (local int i = 0; i < n; i++) {
        if (entry_matches(match_list[i], ctx)) {
            ctx->output_addr = calculate_output(match_list[i], ctx->input_addr);
            return true;  // Cache hit
        }
    }
    return false;  // Cache miss
}

method tlb_cache_update(transaction_context_t *ctx) {
    if (!tlb_cache_enable.val)
        return;
    
    // Create cache entry with page-aligned addresses
    local tlb_cache_entry_t *tc = new tlb_cache_entry_t;
    tc->input_base = ctx->input_addr & ~(ctx->page_size - 1);
    tc->output_base = ctx->output_addr & ~(ctx->page_size - 1);
    tc->page_size = ctx->page_size;
    // ... (copy context attributes)
    
    insert_interval(&tlb_cache, tc->input_base, tc->input_base + tc->page_size - 1, tc);
}

method tlb_invalidate_all() {
    // Iterate and collect all cache entries
    interval_set_iter_t it;
    interval_set_new_iter(&tlb_cache, &it, 0, -1);
    // ... collect entries ...
    tlb_invalidate(entry_list);
}

method tlb_invalidate(range_node_list_t rnl) {
    for (each entry in rnl) {
        remove_interval(&tlb_cache, entry->start, entry->end, entry->ptr);
        delete entry->ptr;
    }
    SIM_translation_changed(obj);  // Notify Simics
}
```

**Description:**
- **Interval Tree**: Efficient data structure for range-based address lookups
- **tlb_cache_lookup**: Query tree → match context → return cached output (hit) or false (miss)
- **tlb_cache_update**: Create entry → set page-aligned addresses → insert into tree
- **tlb_invalidate_all**: Iterate all entries → call tlb_invalidate
- **tlb_invalidate**: Remove entries from tree → notify Simics via `SIM_translation_changed()`
- **Performance**: Dramatically reduces translation overhead for repeated memory accesses

## 4. Register Side-Effects and Command Processing

MMU registers trigger various side-effects when accessed, implementing command queuing, TLB management, and error handling.

#### Bank Transaction Access Control

Controls secure/non-secure access to register banks:

```dml
bank tcu {
    param partial = true;
    param use_io_memory = false;

    session conf_object_t *initiator;

    method transaction_access(transaction_t *t, uint64 offset,
                              void *aux) -> (exception_type_t) {
        local bool ns = ATOM_get_transaction_arm_nonsecure(t);

        if ((offset & NS_SPACE.val) != 0) {
            offset &= ~NS_SPACE.val;
            ns = true;
        }

        if (ns && offset >= 0x8000 && offset < 0x10000) {
            log info, 2: "Non-Secure access to secure offset (0x%x) is RAZ/WI", offset;
            if (SIM_transaction_is_read(t))
                SIM_set_transaction_value_le(t, 0);
            return Sim_PE_No_Exception;
        } else {
            initiator = SIM_transaction_initiator(t);
            return default(t, offset, aux);
        }
    }
}
```

**Description:**
- **Security Policy**: Enforces secure/non-secure register separation
- **RAZ/WI**: Read-As-Zero/Write-Ignored for illegal accesses
- **NS_SPACE Handling**: Supports address-based security determination
- **Offset Range**: Secure registers at 0x8000-0x10000
- **Initiator Tracking**: Stores transaction initiator for later use
- **Atom Extraction**: Uses ARM-specific atoms for security state

#### Register Write Side-Effect: Command Queue Processing

Command queue producer register triggers command execution:

```dml
register smmu_cmdq_prod size 4 @ 0x098 {
    field wr @ [19:0] is (read, write) "Queue write index and wrap flag" {

        method write(uint64 value) {
            this.val = value;
            if (tcu.smmu_gerror.cmdq_err.val == 0)
                execute_command(false);
        }
    }
}
```

**Description:**
- **Producer Index**: Software writes to enqueue commands
- **Automatic Execution**: Triggers command processing immediately
- **Error Check**: Only executes if no command queue error is present
- **Write-Through**: Updates register value first, then executes
- **Queue Management**: Works with consumer index to track command queue state

#### Register Write Side-Effect: Error Acknowledgment

Error acknowledgment clears error and restarts processing:

```dml
register smmu_gerrorn size 4 @ 0x064 {
    field cmdq_err @ [0] is (read, write) {
        method write(uint64 value) {
            this.val = value;
            if (tcu.smmu_gerror.cmdq_err.val == 1) {
                // Commands at or after the CMDQ_CONS.RD position are
                // fetched or re-fetched after command processing is
                // restarted by acknowledging CMDQ_ERR
                tcu.smmu_gerror.cmdq_err.val = 0;
                execute_command(false);
            }
        }
    }
}
```

**Description:**
- **Write-1-to-Clear**: Writing 1 acknowledges and clears the error
- **Restart Logic**: Resumes command processing from consumer index
- **Error Recovery**: Allows software to recover from command errors
- **State Synchronization**: Clears error bit and restarts queue processing atomically

#### Register Write Side-Effect: Global Invalidation

Secure initialization register with TLB invalidation:

```dml
register smmu_s_init size 4 @ 0x803C {
    field inv_all @ [0] is (read, write) "Invalidate all cache and TLB contents" {
        method write(uint64 value) {
            if (smmu_cr0.smmuen.val == 1 || smmu_s_cr0.smmuen.val == 1) {
                log info, 2: "SMMU_S_INIT.INV_ALL write ignored";
            } else if (value == 1) {
                tlb_invalidate_all();
            }
        }
    }
}
```

**Description:**
- **Conditional Invalidation**: Only works when SMMU is disabled
- **Safety Check**: Prevents invalidation during active operation
- **Write-1-to-Trigger**: Writing 1 triggers the invalidation
- **Global Scope**: Invalidates all TLB entries across all contexts
- **Initialization**: Typically used during boot or reset sequences

#### Register Read-Only Pattern

Acknowledgment register mirrors control register state:

```dml
register smmu_cr0ack size 4 @ 0x024 is (read, read_only) {
    method read() -> (uint64) {
        return smmu_cr0.get();
    }
}
```

**Description:**
- **Read-Only**: Cannot be written by software
- **Shadow Register**: Mirrors control register state
- **Acknowledgment**: Indicates MMU has processed control register changes
- **Synchronization**: Provides software visibility into hardware state

#### Template-based Register Pattern

Reusable template for ATOS (Address Translation Operation Service) registers:

```dml
template gatos_ctrl {
    is register;
    field run @ [0] is (read, write) "Run ATOS translation";
    param secure = offset > 0x8000;
    method write_register(uint64 value, uint64 enabled_bytes, void *aux) {
        default(value, enabled_bytes, aux);
        if (run.val) {
            atos_translate(initiator, secure);
            run.val = 0;
        }
    }
}

// Usage
register smmu_gatos_ctrl size 4 @ 0x100 is (gatos_ctrl);
register smmu_s_gatos_ctrl size 4 @ 0x8100 is (gatos_ctrl);
```

**Description:**
- **Template Reuse**: Single template instantiated for secure and non-secure versions
- **Self-Clearing**: Run bit automatically clears after translation
- **Security Context**: Uses offset to determine secure parameter
- **On-Demand Translation**: Performs address translation service when triggered
- **Initiator Tracking**: Passes original transaction initiator to translation
- **Atomic Operation**: Write triggers translation and clears bit in one operation

## 5. Memory Transaction Handling

Secure memory access with ARM-specific attributes and MSI support.

#### Memory Read with Security Check

```dml
method read_mem(bool is_secure, void *dst, physical_address_t src,
                       physical_address_t len) -> (bool)
{
    local exception_type_t ex;
    local atom_t atoms[6] = {
        ATOM_arm_nonsecure(!is_secure),
        ATOM_flags(0),
        ATOM_size(len),
        ATOM_data(dst),
        ATOM_initiator(dev.obj),
        ATOM_list_end(0)
    };
    local transaction_t t;
    t.atoms = atoms;
    if (!is_secure)
        src |= NS_SPACE.val;
    ex = SIM_issue_transaction(target_mem_space.map_target, &t, src);

    if (ex != Sim_PE_No_Exception)
        SIM_clear_exception();

    return (ex == Sim_PE_No_Exception);
}
```

**Description:**
- **Security Attribute**: Sets ARM non-secure atom based on security state
- **Address Space**: Applies NS_SPACE offset for non-secure accesses
- **Transaction Atoms**: Uses Simics atom API for ARM-specific attributes
  - `ATOM_arm_nonsecure`: Security state
  - `ATOM_flags`: Transaction flags (0 for read)
  - `ATOM_size`: Transfer size
  - `ATOM_data`: Buffer pointer
  - `ATOM_initiator`: Device making the access
- **Error Handling**: Clears exception and returns status
- **Return Value**: True if successful, false on exception

#### Memory Write with MSI Support

```dml
method _write_mem(bool is_secure, void *src, physical_address_t dst,
                 physical_address_t len, bool is_msi) -> (bool) {
    local atom_t atoms[7] = {
        ATOM_arm_nonsecure(!is_secure),
        ATOM_flags(Sim_Transaction_Write),
        ATOM_size(len),
        ATOM_data(src),
        ATOM_initiator(dev.obj),
        (is_msi && tcu_sid.val != SID_NOT_SET) ? ATOM_arm_device_id(tcu_sid.val)
                                               : ATOM_list_end(0),
        ATOM_list_end(0)
    };
    local transaction_t t;
    t.atoms = atoms;
    if (!is_secure)
        dst |= NS_SPACE.val;

    local exception_type_t ex;
    ex = SIM_issue_transaction(target_mem_space.map_target, &t, dst);

    if (ex != Sim_PE_No_Exception)
        SIM_clear_exception();

    return (ex == Sim_PE_No_Exception);
}
```

**Description:**
- **Write Flag**: Sets `Sim_Transaction_Write` flag for write operation
- **MSI Support**: Conditionally adds device ID atom for Message Signaled Interrupts
- **Device ID**: Uses configured TCU SID for MSI transactions
- **Conditional Atom**: Uses ternary operator to include/exclude MSI atom
- **Error Handling**: Same pattern as read - clear and return status
- **Use Cases**:
  - Normal writes: `is_msi = false`
  - MSI writes to interrupt controller: `is_msi = true`


## Summary

This document demonstrates key DML 1.4 implementation patterns for MMU devices:

1. **Device Structure**: Connect interfaces, attributes, and configuration
2. **Dual Translator Interfaces**: Legacy and transaction-based implementations
3. **Two-Stage Translation**: Complete VA→IPA→PA translation pipeline
4. **Page Table Walking**: Multi-level table walk with descriptor processing
5. **TLB Caching**: High-performance interval tree-based translation cache
6. **Register Side-Effects**: Command processing, error handling, and invalidation
7. **Memory Transactions**: Secure/non-secure memory access with ARM atoms

The implementation demonstrates:
- Full ARM SMMUv3 architecture compliance
- Efficient caching mechanisms for performance
- Comprehensive security state handling
- Flexible bypass and override capabilities
- Professional-grade error detection and reporting
- Clean separation between translation stages
- Reusable templates for register patterns
